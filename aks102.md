# Beginners Lab

## Table of Contents

[Overview](#overview)

[Pre-Requisites](#Pre-requisites)

[Practice 1: Namespaces](#practice-1-namespaces)

[Practice 2: Pods](#practice-2-pods)

[Practice 3: Services](#practice-3-services)

[Practice 4: ConfigMaps](#practice-4-configMaps)

[Practice 5: Secrets](#practice-5-secrets)

[Practice 6: Deployments](#practice-6-deployments)


## Overview

At the end of this lab, you'll learn  about yaml files , docker containers, creating, updating, describe, edit and delete a few Kubernetes Objects like Namespaces, Pods, Services, ConfigMaps, Secrets, Deployments.


## Pre-Requisites

### Introduction to yaml:

yaml is just another way to represent an object like xml and json but more user friendly.

the simplest definition of a yaml stands as a **collection of one or more hashes (called maps)**

a hash / map is a key value pair, sepearted by a colon and a space. like, 

`name: jack`

key is name and value is jack

and collection of maps is like
```
lastname: nicholson
fistname: jack
```
the value of a map could be a another map , but is indented by atleast one space ( do not use tabs)
```
name:
 last: nicholson
```
or collection of maps
```
name:
 last: nicholson
 first: jack
```
or an array (list), each element of the array should start with - (a hyphen) and one space and must be indented at least by one space.

``` yaml
names:
 - name:
    last: nicholson
    first: jack
 - name:
    last: golds
    first: jill
```

Any object can be represented using these rules.

A typical kubernetes manifest is a yaml file that has an apiversion of the resource ( object), name of the object) and its specification under the spec. 

here is an example of pod yaml file

``` yaml
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu
  labels:
    app: ubuntu
spec:
  containers:
  - name: ubuntu
    image: ubuntu:latest
    command: ["sleep","30d"]
    volumeMounts:
    - name: docker
      mountPath: /var/run/docker.sock
    - name: dockerlib
      mountPath: /var/lib/docker
  volumes:
  - name: docker
    hostPath: 
      path: /var/run/docker.sock
      type: File
  volumes:
  - name: dockerlib
    hostPath: 
      path: /var/lib/docker
      type: File

```

the value of key `apiVersion is v1`, you might also see other versions used like `apps/v1 extensions/v1beta1`, these are api versions of the api server and show the evolution of different kubernetes objects (resources)

the value of key kind is Pod, indicating that the object we are trying to represent in this yaml is a Pod.

metadata has a value which is a map `name=ubuntu` (.metadata.name) and a collection of maps labels (.metadata.labels), whose value is a map, whose key is app **(.metadata.labels.app)** and value is ubuntu.

**spec** is the specification of the pod, which may contain one or more containers, so you see that the info about the first container starts with - and a space.

similarly volumeMounts is an array of maps, but has two items **docker** and **dockerlibs**

Also notice another way to represent array in the command and args keys using `["value1","value2"]` format

Using yaml files, especially committed to a github repo, is one of the best practices for kubernetes.


### What is a container?

**A container is like a vm, it can be started using an image.**

this command starts a ubuntu container and gives user a shell into it

`kubectl run ubuntu --rm -ti  --image=ubuntu /bin/sh`

If you don't see a command prompt, try pressing enter.

in the prompt run

`uname -a`

the output is

```
Linux ubuntu-65887fbbcb-2x8dl 4.14.35-1844.4.5.2.el7uek.x86_64 #2 SMP Fri May 3 00:49:55 PDT 2019 x86_64 x86_64 x86_64 GNU/Linux

```

`cat /etc/*release`

Returns you the details of the ubuntu release

```
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.2 LTS"
NAME="Ubuntu"
VERSION="18.04.2 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.2 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
```
type **exit** to exit container, stop and remove it.

Try it again to see how fast the container starts as compared to a vm.

**A container is not like a vm, it can be started almost instantaneously.**

We can choose a different os version by choosing a different image. In the previous command we used the image name as just ubuntu.
If there is no tag after the image name then the default tag(version) is (:)latest, in the following command the tag is (:)16.04, usually it is better to tag the image or specify a particular tag 

**example:**

imagename:imagetag

run the following command using image 16.04 version of ubuntu,

`kubectl run ubuntu16 --rm -ti  --image=ubuntu:16.04 /bin/sh`

If you don't see a command prompt, try pressing enter.

run the previous commands again inside the container.

`# uname -a`

Linux ubuntu16-65b6d64c45-njx2k 4.14.35-1844.4.5.2.el7uek.x86_64 #2 SMP Fri May 3 00:49:55 PDT 2019 x86_64 x86_64 x86_64 GNU/Linux

`# cat /etc/*release`

```
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=16.04
DISTRIB_CODENAME=xenial
DISTRIB_DESCRIPTION="Ubuntu 16.04.6 LTS"
NAME="Ubuntu"
VERSION="16.04.6 LTS (Xenial Xerus)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 16.04.6 LTS"
VERSION_ID="16.04"
HOME_URL="http://www.ubuntu.com/"
SUPPORT_URL="http://help.ubuntu.com/"
BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"
VERSION_CODENAME=xenial
UBUNTU_CODENAME=xenial
notice how the release is now 16.04
```

type exit to get out of the container

**A container image can be changed very easily, and the the OS version can also be changed very easily**

What if we did not want ubuntu, we want alpine linux.

then run this command

`kubectl run alpine --rm -ti  --image=alpine:3.10 /bin/sh`

If you don't see a command prompt, try pressing enter.

`/ # uname -a`
```
Linux alpine-75f679b4c6-hn5z2 4.14.35-1844.4.5.2.el7uek.x86_64 #2 SMP Fri May 3 00:49:55 PDT 2019 x86_64 Linux
```
`/ # cat /etc/*release`

```
3.10.0
NAME="Alpine Linux"
ID=alpine
VERSION_ID=3.10.0
PRETTY_NAME="Alpine Linux v3.10"
HOME_URL="https://alpinelinux.org/"
BUG_REPORT_URL="https://bugs.alpinelinux.org/"
/ #

```

type exit to get out of the container

**A container image OS can also be changed very easily**

notice that we are running a different os now alpine linux, most linux distros have images on docker hub.

windows images are also posssible but requires the underlying vms to be windows also and are beyond our scope.

What can developers do with just the os, other software needs to be installed on top of it for their code to work.

**Container images come preinstalled with the required software and their dependencies.**

A java developer can use the openjdk image...

run the following command to run a container that has jdk installed 

`kubectl run openjdk --rm -ti  --image=openjdk /bin/sh`

this may take a while as the image is larger in size


`uname -a`

```
Linux openjdk-79d9767788-pcj8x 4.14.35-1844.4.5.2.el7uek.x86_64 #2 SMP Fri May 3 00:49:55 PDT 2019 x86_64 x86_64 x86_64 GNU/Linux
```

`cat /etc/*release`

```
Oracle Linux Server release 7.6
NAME="Oracle Linux Server"
VERSION="7.6"
ID="ol"
VARIANT="Server"
VARIANT_ID="server"
VERSION_ID="7.6"
PRETTY_NAME="Oracle Linux Server 7.6"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:oracle:linux:7:6:server"
HOME_URL="https://linux.oracle.com/"
BUG_REPORT_URL="https://bugzilla.oracle.com/"

ORACLE_BUGZILLA_PRODUCT="Oracle Linux 7"
ORACLE_BUGZILLA_PRODUCT_VERSION=7.6
ORACLE_SUPPORT_PRODUCT="Oracle Linux"
ORACLE_SUPPORT_PRODUCT_VERSION=7.6
Red Hat Enterprise Linux Server release 7.6 (Maipo)
Oracle Linux Server release 7.6

```

run `java -version`

```
openjdk version "12.0.1" 2019-04-16
OpenJDK Runtime Environment (build 12.0.1+12)
OpenJDK 64-Bit Server VM (build 12.0.1+12, mixed mode, sharing)
```
type exit to get out of the container

Notice that the image has java12.0.1 on oracle linux.

What if you are a nodejs developer?

run the following command

`kubectl run node --rm -ti  --image=node:carbon-alpine /bin/sh`

`/ # uname -a`
```
Linux node-6795d6d88d-jjxgg 4.14.35-1844.4.5.2.el7uek.x86_64 #2 SMP Fri May 3 00:49:55 PDT 2019 x86_64 Linux
```
`/ # cat /etc/*release`

```
3.9.4
NAME="Alpine Linux"
ID=alpine
VERSION_ID=3.9.4
PRETTY_NAME="Alpine Linux v3.9"
HOME_URL="https://alpinelinux.org/"
BUG_REPORT_URL="https://bugs.alpinelinux.org/"
```
`/ # node -v`

v8.16.0

`/ # npm -v`

6.4.1

Notice how the os is alpine and node version is 8.16 and npm comes installed with it.

type exit to get out of the container.

**Containers contain everything needed to run particular code, a wide variety of images are available at docker hub.**

for example information about node image is available here

https://hub.docker.com/_/node

https://hub.docker.com/ is the url where you can search for other images. You can also create an account and login to use their public container registry to store your images and make them public if needed. Private images can be pulled from this registry by using the credentials supplied by dockerhub at sign-in.

### Can we customize images?

we can customize images using a Dockerfile, a typical dockerfile looks like below.

```
FROM ubuntu 
RUN apt-get update && apt-get install -y telnet
```

This Dockerfile uses a FROM image as ubuntu and then runs the commands followed by RUN and saves the image.

For a complete list of customizations possible using docker commands, see this url

https://docs.docker.com/engine/reference/builder/


save the following code in a file called dond.yml

``` yaml
apiVersion: v1
kind: Pod
metadata:
  name: dond
  labels:
    app: dond
spec:
  containers:
  - name: dond
    image: docker:latest
    command: ["sleep"]
    args: ["30d"]
    volumeMounts:
    - name: docker
      mountPath: /var/run/docker.sock
    ports:
    - containerPort: 2375
    securityContext:
      privileged: true
  volumes:
  - name: docker
    hostPath: 
      path: /var/run/docker.sock
      type: File
```

now run `kubectl create -f dond.yml`

then get into the container using `kubectl exec -it dond sh`

run docker version to see the version of docker installed

type exit to get out of the container

copy this code into a file called Dockerfile

```
FROM ubuntu 
RUN apt-get update && apt-get install -y telnet
```

then copy the file to the container to the location /usr using the following command
`kubectl cp .\Dockerfile dond:/usr/Dockerfile`

get a shell into the container by running
`kubectl exec -it dond sh`

once inside the container in the shell type.

`cd /usr`

`docker build --network=host -t myubuntu:wtelnet .`



you should see an output like,

```
Sending build context to Docker daemon  165.8MB
Step 1/2 : FROM ubuntu
 ---> 4c108a37151f
Step 2/2 : RUN apt-get update && apt-get install -y telnet
 ---> Running in c0814339c962
Get:1 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]
Get:2 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]
Get:3 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB]
Get:4 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Get:5 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB]
Get:6 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB]
Get:7 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB]
Get:8 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB]
Get:9 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [10.8 kB]
Get:10 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [7239 B]
Get:11 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [1239 kB]
Get:12 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [885 kB]
Get:13 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [3927 B]
Get:14 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [2496 B]
Get:15 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [4169 B]
Get:16 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [5436 B]
Get:17 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [721 kB]
Get:18 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [577 kB]
Fetched 16.8 MB in 2s (7759 kB/s)
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  netbase
The following NEW packages will be installed:
  netbase telnet
0 upgraded, 2 newly installed, 0 to remove and 8 not upgraded.
Need to get 79.8 kB of archives.
After this operation, 210 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu bionic/main amd64 netbase all 5.4 [12.7 kB]
Get:2 http://archive.ubuntu.com/ubuntu bionic/main amd64 telnet amd64 0.17-41 [67.1 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 79.8 kB in 0s (183 kB/s)
Selecting previously unselected package netbase.
(Reading database ... 4040 files and directories currently installed.)
Preparing to unpack .../archives/netbase_5.4_all.deb ...
Unpacking netbase (5.4) ...
Selecting previously unselected package telnet.
Preparing to unpack .../telnet_0.17-41_amd64.deb ...
Unpacking telnet (0.17-41) ...
Setting up netbase (5.4) ...
Setting up telnet (0.17-41) ...
update-alternatives: using /usr/bin/telnet.netkit to provide /usr/bin/telnet (telnet) in auto mode
update-alternatives: warning: skip creation of /usr/share/man/man1/telnet.1.gz because associated file /usr/share/man/man1/telnet.netkit.1.gz (of link group telnet) doesn't exist
Removing intermediate container c0814339c962
 ---> 69a21530a195
Successfully built 69a21530a195
Successfully tagged myubuntu:v1
```

Now lets compare the images before and after the docker build.

First with the plain ubuntu container, run the following command

`docker run -it ubuntu sh`

Now you are two layers deep in containers, dond container and then in ubuntu container.

and check if telnet exists by running 
`telnet`
(command not found should be the result)
type `exit` to get out of the ubuntu container

Now run with the image we built earlier, myubuntu:wtelnet

`docker run -it myubuntu:wtelnet sh`

and check if telnet exists by running 
`telnet` 
(a telnet session should open, type quit to exit the session)

type `exit` to exit the myubuntu container
type `exit` to exit the dond container

**Containers can contain containers**

Now that we've built an image with telnet installed, it is possible to create an image with any combinations of packages that can exist on a vm.

**Container images can be customized by installing new software**

The image built is usually pushed to a container registry. ( which is a repository for images, dockerhub provides free private registries)
The commands used are

`docker tag myubuntu:v1 myregistryhost/myubuntu:v1`

`docker login myregistryhost`

`docker push myregistryhost/myubuntu:v1`

That will get the image to the repository and can be pulled from the repository using
`docker pull myregistryhost/myubuntu:v1`

**Containers can be started from images which can be customized using Dockerfile and stored in repositories called container registries**


Now we are ready to dive into Kubernetes Objects.

## Practice 1: Namespaces 

In kubernetes, namespace is to categorize objects in a cluster. Namespace can be used to segregate your cluster for multiple dev teams for discrete purposes (eg.dev, stage and prod). Namespace to kubernetes is as directory in a filesystem. It provides isolation for a set of container applications. There are three diffferent namespaces that are created by default, which you can verify by using the following command to show default namespaces in the cluster.

  `kubectl get ns`

  ``` 
    NAME            STATUS    AGE
    default         Active    154d
    kube-public     Active    154d
    kube-system     Active    154d 
  ```
  
**default:** this is the namespace used if namespaces is not mentioned in the command line, or yaml.

**kube-system:** kube-system namespace is for objects generated by the kubernetes. usually this has pods ( containerized applications ) like `kube-dns`, `kube-proxy`, `kubernetes-dashboard`. the following command show all the pods, in a namespace. It is recommended not to disturb any of the set up in this namespace.
  
  `kubectl -n kube-system get pods`
 
  ```
    NAME                                    READY     STATUS    RESTARTS   AGE
    kube-proxy-x8p6w                        1/1       Running   0          39d
    kube-dns-bdcc8c4bb-nmn4b                3/3       Running   0          10d
    kubernetes-dashboard-6c45b65444-nvs9p   1/1       Running   0          48d
  ```
**kube-public**: kube-public namespace is automatically created with the cluster (just like default, kube-system). This content is accessible for the public unauthenticated users and is mainly used for system containers.
  
### Create the namespace

1. To create a namespace in the cluster, use the following command.
 
  `kubectl create ns <namespace-name>`

**Note:** Here test is name the namespace.

  ```
  namespace/test created
  ```

2. Create the namespace by using a manifest file. copy the code below into a file and name it as namespace.yml.

  ```
  apiVersion: v1
  kind: Namespace
  metadata:
    name: <namespace-name>
  ```
   Create a Namespace by using `kubectl` command line-tool.
   
   `kubectl create -f <filename>`

  `kubectl create -f C:\Users\Documents\Labs-Kube\namespace.yml`

  ```
  namespace/test created
  ```
 
3. Check by using `kubectl get ns` listout the all namespaces in a cluster. 
 
  `kubectl get ns`
  
  ```
  NAME            STATUS    AGE
  default         Active    154d
  kube-public     Active    154d
  kube-system     Active    154d
  test            Active    2m
  ```
### Delete the namespace

1. To delete the namespace use by the following command to delete namespace. Please note that this is irreversible.

  `kubectl delete ns <namespace-name>`

  ```  
  namespace "test" deleted
  ```
## Practice 2: Pods

A container is like a VM , as it can provide all the software necessary for the application to run and isolates it from other containers, it is not like a vm, as it has no os of its own, and uses hosts kernel. Containers are faster to start, can self heal, easily scale, easily updatable, when compared with VMs. Usually containers are tasked with one job, as a http server, as a db, as a proxy. A Pod is a collection of application containers running on the same node. Pods, not containers, are the smallest deployable artifacts in a kubernetes cluster, which means all of the containers in a pod always launch on same machine.

![alt-txt](https://raw.githubusercontent.com/sysgain/qloudable-tl-labs/aks/AKS%20Course/images/pod.png?token=AIMANTEWGNAYBDUZLDXYUHC5JJWMG)

### Create a pod

1. Pod manifests can be written using YAML or JSON, but YAML is usually preferred because it is easier to edit, and comments can be added where necessary. In our labs we will use YAML files whcich are text files which have ending like .yml or .yaml.

2. Pod manifests (YAML files) include a few key fields and attributes.

   * metadata section for describing the pod's name and its namespace, a spec section  for describing volumes, images, container port, imagepullsecrets and many more, a list of containers that will run in the Pod.

3. Create a namespace using `kubectl create ns <namespace-name>`.

4. Below YAML is used to create the pod, change the nampespace name in the YAML.

5. Save the pod YAML file and deploy it using `kubectl create -f <file path>`

``` yaml
apiVersion: v1
kind: Pod
metadata:
  name: http-service
  namespace: <namespace-name>
  labels:
    run: my-nginx
spec:
  containers:
  - name: my-nginx
    image: nginx:1.7.9
    ports:
    - containerPort: 80
```


4. The pod manifest will be submitted to the kubernetes API server.

5. The kubernetes system will then schedule that pod to run on a healthy node in the cluster, where it will be monitored by kubelet daemon process.

### Get the pods

1. List out the pods running in a namespace, by using a following command.

  Ex: `kubectl -n <namespace-name> get pods`

  `kubectl -n <namespace-name> get pods`

  ```
  NAME      READY     STATUS    RESTARTS   AGE
  testpod   1/1       Running   0          4m
  ```

2. You can see the name of pod (testpod) that gave it in previous YAML file. In addition to that number of ready containers, the output also shows the status, the number of times pod was restarted, as well as the age of the pod.

### Describe the Pod details

1. To findout more information about a pod(or any kubernetes object), use kubectl describe command.

  `kubectl -n <namespace-name> describe po testpod`
  
  ``` 
  Name:               testpod
  Namespace:          test
  Priority:           0
  PriorityClassName:  <none>
  Node:               10.0.1.2/10.0.1.2
  Start Time:         Thu, 09 May 2019 14:59:57 +0530
  Labels:             <none>
  Annotations:        <none>
  Status:             Running
  IP:                 10.244.2.212
  Containers:
    testcontainer:
      Container ID:   docker://ac817bc882ee3e4171dad8a22dde752b247dba910d4f5707e9456ce743714333
      Image:          nginx
      Image ID:       docker-pullable://nginx@sha256:1d0dfe527f801c596818da756e01fa0e7af4649b15e
      Port:           80/TCP
      Host Port:      0/TCP
      State:          Running
        Started:      Thu, 09 May 2019 15:00:06 +0530
      Ready:          True
      Restart Count:  0
      Environment:    <none>
      Mounts:
        /var/run/secrets/kubernetes.io/serviceaccount from default-token-qckb2 (ro)
  Conditions:
    Type              Status
    Initialized       True
    Ready             True
    ContainersReady   True
    PodScheduled      True
  Volumes:
    default-token-qckb2:
      Type:        Secret (a volume populated by a Secret)
      SecretName:  default-token-qckb2
      Optional:    false
  QoS Class:       BestEffort
  Node-Selectors:  <none>
  Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                  node.kubernetes.io/unreachable:NoExecute for 300s
  Events:
    Type    Reason     Age   From               Message
    ----    ------     ----  ----               -------
    Normal  Scheduled  6m    default-scheduler  Successfully assigned test/testpod to 10.0.1.2
    Normal  Pulling    6m    kubelet, 10.0.1.2  pulling image "nginx"
    Normal  Pulled     6m    kubelet, 10.0.1.2  Successfully pulled image "nginx"
    Normal  Created    6m    kubelet, 10.0.1.2  Created container
    Normal  Started    6m    kubelet, 10.0.1.2  Started container
  ```

2. Add the -o wide to any kubectl command, it will print out more information.

  `kubectl -n <namespace-name> get po testpod -o wide`

  ```
  NAME      READY     STATUS    RESTARTS   AGE       IP            NODE       NOMINATED NODE
  testpod   1/1       Running   0          43h       10.244.1.77   10.0.0.2   <none>
  ```

### Logs of the pod

1. Kubectl logs command downloads the current logs from the running instance.

2. Adding `-f` flag will allow to continuously stream logs.

  `kubectl -n <namespace-name> logs testpod`

3. the details for a single pod as a YAML formatted object using  `kubectl -n (namespacename)  get pod (podname)--o yaml`

```
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: 2019-06-03T07:05:56Z
  generateName: my-nginx-64fc468bd4-
  labels:
    pod-template-hash: 64fc468bd4
    run: my-nginx
  name: my-nginx-64fc468bd4-2wqtm
  namespace: beginner
  ownerReferences:
  - apiVersion: apps/v1
    blockOwnerDeletion: true
    controller: true
    kind: ReplicaSet
    name: my-nginx-64fc468bd4
    uid: 08793b8b-85ce-11e9-8de0-ae472d92dc51
  resourceVersion: "2633843"
  selfLink: /api/v1/namespaces/beginner/pods/my-nginx-64fc468bd4-2wqtm
  uid: 0880e46b-85ce-11e9-8de0-ae472d92dc51
spec:
  containers:
  - env:
    - name: KUBERNETES_PORT_443_TCP_ADDR
      value: aztlcluster59-dns-304b8663.hcp.eastus.azmk8s.io
    - name: KUBERNETES_PORT
      value: tcp://aztlcluster59-dns-304b8663.hcp.eastus.azmk8s.io:443
    - name: KUBERNETES_PORT_443_TCP
      value: tcp://aztlcluster59-dns-304b8663.hcp.eastus.azmk8s.io:443
    - name: KUBERNETES_SERVICE_HOST
      value: aztlcluster59-dns-304b8663.hcp.eastus.azmk8s.io
    image: nginx
    imagePullPolicy: Always
    name: my-nginx
    ports:
    - containerPort: 80
      protocol: TCP
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-9z8r4
      readOnly: true
  dnsPolicy: ClusterFirst
  enableServiceLinks: true
  nodeName: aks-agentpool-33375343-0
  priority: 0
  restartPolicy: Always
  schedulerName: default-scheduler
  securityContext: {}
  serviceAccount: default
  serviceAccountName: default
  terminationGracePeriodSeconds: 30
  tolerations:
  - effect: NoExecute
    key: node.kubernetes.io/not-ready
    operator: Exists
    tolerationSeconds: 300
  - effect: NoExecute
    key: node.kubernetes.io/unreachable
    operator: Exists
    tolerationSeconds: 300
  volumes:
  - name: default-token-9z8r4
    secret:
      defaultMode: 420
      secretName: default-token-9z8r4
status:
  conditions:
  - lastProbeTime: null
    lastTransitionTime: 2019-06-03T07:05:56Z
    status: "True"
    type: Initialized
  - lastProbeTime: null
    lastTransitionTime: 2019-06-03T07:06:00Z
    status: "True"
    type: Ready
  - lastProbeTime: null
    lastTransitionTime: 2019-06-03T07:06:00Z
    status: "True"
    type: ContainersReady
  - lastProbeTime: null
    lastTransitionTime: 2019-06-03T07:05:56Z
    status: "True"
    type: PodScheduled
  containerStatuses:
  - containerID: docker://817274bf3fe0d82541e7e035be0c5e11663a927bcc1ba75aca3f26767900f88c
    image: nginx:latest
    imageID: docker-pullable://nginx@sha256:23b4dcdf0d34d4a129755fc6f52e1c6e23bb34ea011b315d87e193033bcd1b68
    lastState: {}
    name: my-nginx
    ready: true
    restartCount: 0
    state:
      running:
        startedAt: 2019-06-03T07:05:59Z
  hostIP: 10.240.0.4
  phase: Running
  podIP: 10.244.0.209
  qosClass: BestEffort
  startTime: 2019-06-03T07:05:56Z
```
4. see the schedule node and ip address `kubectl -n  (namespacename)  get pod (podname) -o wide`

```
NAME                        READY     STATUS    RESTARTS   AGE       IP             NODE
my-nginx-64fc468bd4-2wqtm   1/1       Running   0          14m       10.244.0.209   aks-agentpool-33375343-0
```


### Running Commands in a Container with exec

1. Execute the commands in the conditions of container itself. Get an interactive session by adding the `-it` flag.

  `kubectl -n <namespace-name> exec -it testpod bash`

2. If you want to install packages or resources like (ps -ef, curl) into a container.

  `root@testpod:/# apt-get update`
  
  `root@testpod:/# apt-get install curl`
  
  `root@testpod:/#  apt-get update && apt-get install -y procps `


### Edit the pod

1. Edit a pod using a below command, this will popup a pod file, if any addition to pod file add to here. If any changes made, this pod will restart. 

  `kubectl -n <namespace-name> edit po testpod`
 
  ```
  Edit cancelled, no changes made
  ```
 
### Delete the pod

* To delete a pod, can delete it either by name or same file used to create it.
* When a Pod is deleted, it is not immediately killed. Instead, if run kubectl get pods, will see that the Pod is in the Terminating state.

  `kubectl -n <namespace-name> delete po testpod`

  ```
  pod "testpod" deleted`
  ```
to terminate a pod immediately use options --grace-period=0 --force

## Practice 3: Services

A Service is a Kubernetes object used to define a logical set of **Pods** and also create a policy by which other service can access them. The logical set of pods that is under a service is determined by a **Label Selector**.

**Types of Services**

1. ClusterIp
2. NodePort
3. LoadBalancer
4. ExternalName
5. ExternalIPs


### ClusterIP

ClusterIP service is the default service type in kubernetes cluster. It exposes the service on a cluster-internal IP. This type of service are reachable from within the cluster. Below is code for a clusterIP type service, use the command `kubectl create -f <filename-name>` to deploy the service.

  ``` yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    ports:
      - name: tcp-8089
      protocol: TCP
      port: 8089
      targetPort: 8089
    selector:
      service-name: test-service

  ```

### NodePort

NodePort type of service exposes the service on each node's IP at a static port. One can access a NodePort type service from outside of the cluster, by accessing the <NodeIP>:<StaticPort>. Below is code for a NodePort type service, use the command `kubectl create -f <filename-name>` to deploy the service.


![alt-txt](https://raw.githubusercontent.com/sysgain/qloudable-tl-labs/aks/AKS%20Course/images/nodeport.png?token=AIMANTFUXYMWXYVZ2WFC4FS5JJWMA)

  ``` yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    type: NodePort
    ports:
      - name: tcp-8089
      protocol: TCP
      port: 8089
      targetPort: 8089
    selector:
      service-name: test-service
  ```

### LoadBalancer

LoadBalancer type of service exposes the service externally using a cloud provider's Load Balancer resource (ie Azure Load Balancer in AKS, Elastic Load Balancer in Amazon EKS). One can access a LoadBalancer type service from outside of the cluster, by accessing the <LoadBalancerPublicIP>:<Port>. Below is code for a LoadBalancer type service, use the command `kubectl create -f <filename-name>` to deploy the service.

![alt-txt](https://raw.githubusercontent.com/sysgain/qloudable-tl-labs/aks/AKS%20Course/images/loadbalancer%20.png?token=AIMANTDQN5VWDUYG6YEJAQS5JJWLO)


  ```  yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    type: LoadBalancer
    loadBalancerIP: <replace-with-IP-of-LB>
    ports:
      - name: tcp-8089
      protocol: TCP
      port: 8089
      targetPort: 8089
    selector:
      service-name: test-service
  ```

###  ExternalName

ExternalName type of the service maps the service to the contents of the externalName field, by returning a CNAME record with its vault. This type of service requires version 1.7 or higher of **kube-dns**. Below is code for a ExternalName type service, use the command `kubectl create -f <filename-name>` to deploy the service.

  ``` yaml
  kind: Service
  apiVersion: v1
  metadata:
    name: test-service
    labels:
      service-name: test-service
  spec:
    type: ExternalName
    externalName: test-service.example.com
  ```


### ExternalIPs

If there are ExternalIP's that route traffic to the cluster nodes, then kubernetes services can be exposed on those **externalIPs**. Traffic that ingresses into the cluster with the external IP (as destination IP), on the service port, will be routed to one of the service endpoints. In the **ServiceSpec**, **externalIPs** can be specified along with any of the **ServiceTypes**. In the example below, db-service can be accessed by client on the IP

![alt-txt](https://raw.githubusercontent.com/sysgain/qloudable-tl-labs/aks/AKS%20Course/images/Externalip.png?token=AIMANTDJ6JLOXDTXO7HW2DC5JJWTK)

  ``` yaml
  kind: Service
  apiVersion: v1
  metadata:
    name: db-service
  spec:
    selector:
      service-name: db-service
    ports:
    - name: http
      protocol: TCP
      port: 28015
      targetPort: 28015
    externalIPs:
    - <replace-with-external-service-IP-address>
```
create nginx app service using `kubectl -n (namespacename)  apply -f E:\nginxsvc.yaml`
service "my-nginx" created

```  
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    run: my-nginx
spec:
  ports:
  - port: 80
    protocol: TCP
  selector:
    run: my-nginx
```

### Get list of services

To get a list of services in a namespace use the command `kubectl -n <namespace-name> get services`

```
NAME              TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
cluster-service   ClusterIP   10.0.244.2     <none>        8089/TCP   6d
my-nginx          ClusterIP   10.0.25.40     <none>        80/TCP     6m
nginx             ClusterIP   10.0.241.196   <none>        8089/TCP   18m
```

### Describe a service

To describe and get more info on a service use the command `kubectl -n <namespace-name> describe service <service-name>`

  ``` 
  Name:              test-service
  Namespace:         test-service
  Labels:            service-name=test-service
  Annotations:       <none>
  Selector:          service-name=test-service
  Type:              ClusterIP
  IP:                10.96.235.1
  Port:              <unset>  8089/TCP
  TargetPort:        8089/TCP
  Endpoints:         <none>
  Session Affinity:  None
  Events:            <none>
  ```

### Edit a Service

To edit a Service resource in a namespace use the command `kubectl -n <namespace-name> edit service <service-name>`

The currently deployed service resource YAML will be opened in a text editor and you can edit as per the requirement then save the file, this will update the service resource successfully. Make sure the YAML syntax is followed.

### labels

![alt-txt](https://raw.githubusercontent.com/sysgain/qloudable-tl-labs/aks/AKS%20Course/images/labels.png?token=AIMANTEOF7W5PHZGEXFY7D25JJWLS)

Get labels using `kubectl -n (namespacename)  get po --show-labels`
```
NAME                        READY     STATUS    RESTARTS   AGE       LABELS
my-nginx-64fc468bd4-2wqtm   1/1       Running   0          7m        pod-template-hash=64fc468bd4,run=my-nginx
my-nginx-64fc468bd4-jwf4v   1/1       Running   0          7m        pod-template-hash=64fc468bd4,run=my-nginx
```

list out the  pods with label  using   `kubectl -n (namespacename) get po -l run=my-nginx`

```
NAME                        READY     STATUS    RESTARTS   AGE
my-nginx-64fc468bd4-2wqtm   1/1       Running   0          20m
my-nginx-64fc468bd4-jwf4v   1/1       Running   0          20m
```
add the labeles label=label  using `kubectl -n (namespacename) label po (podname) label=label
pod "my-nginx-64fc468bd4-2wqtm" labeled

see the added labels using `kubectl -n (namespacename) get po --show-labels`

```
NAME                        READY     STATUS    RESTARTS   AGE       LABELS
my-nginx-64fc468bd4-2wqtm   1/1       Running   0          22m       label=label,pod-template-hash=64fc468bd4,run=my-nginx
my-nginx-64fc468bd4-jwf4v   1/1       Running   0          22m       pod-template-hash=64fc468bd4,run=my-nginx
```

show the all pods using label=label using `kubectl -n (namespacename) get po -l label=label` 

```
NAME                        READY     STATUS    RESTARTS   AGE
my-nginx-64fc468bd4-2wqtm   1/1       Running   0          23m

```

### Access the services 

Accesing the services using service names  here see the same output for localhost and service names.

access the pod using `kubectl -n beginner exec -it my-nginx-64fc468bd4-2wqtm bash`
```
root@my-nginx-64fc468bd4-2wqtm:/# apt-get update
Ign:1 http://cdn-fastly.deb.debian.org/debian stretch InRelease
Get:3 http://cdn-fastly.deb.debian.org/debian stretch-updates InRelease [91.0 kB]
Get:2 http://security-cdn.debian.org/debian-security stretch/updates InRelease [94.3 kB]
Get:4 http://cdn-fastly.deb.debian.org/debian stretch Release [118 kB]
Get:5 http://cdn-fastly.deb.debian.org/debian stretch Release.gpg [2434 B]
Get:6 http://cdn-fastly.deb.debian.org/debian stretch-updates/main amd64 Packages [27.2 kB]
Get:7 http://security-cdn.debian.org/debian-security stretch/updates/main amd64 Packages [492 kB]
Get:8 http://cdn-fastly.deb.debian.org/debian stretch/main amd64 Packages [7082 kB]
Fetched 7907 kB in 2s (3611 kB/s)
Reading package lists... Done
``` 

`Curl <servicename>:port` 

`curl localhost:80`

```
root@my-nginx-64fc468bd4-2wqtm:/# curl localhost:80
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

Services its called by service names 

`curl my-nginx:80`



```
root@my-nginx-64fc468bd4-2wqtm:/# curl my-nginx:80
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

### Delete a service

To delete a service use the command `kubectl -n <namespace-name> delete service <service-name>`

This will delete the service resource.

## Practice 4: ConfigMaps

ConfigMaps are used to provide configuration information (environment variables) for containarized workloads, it is a kubernetes object that defines small filesystem. THese variables can also set from command line.
The basic thing is that the ConfigMap is combined with the Pod right before it is run, means that the container image and the pod definition itself can be reused across many apps by just changing the ConfigMap that is used.

### Create a ConfigMaps

1. Using a configMap there are three main ways to use configMaps:

  **Filesystem:**
      can mount into a pod. A file is created for each entry based on the key name. The content of the file is set to value.
      
  **Environment variable:**
      ConfigMap can be used to dynamically set the value of an Environment variable.
      
  **Command-line argument:**
      Kubernetes supports dynamically creating the command line for a container based on ConfigMap values.

2. Create a configMap with a filename `test-cm.yml`, by using a following command.

  `kubectl -n <namespace> apply -f test-cm.yml`

  ``` yaml
  kind: ConfigMap 
  apiVersion: v1 
  metadata:
    name: test-cm
  data:
    # Configuration values can be set as key-value properties
    database: mongodb
    database_uri: mongodb://localhost:27017
    
    # Or set as complete file contents (even JSON!)
    keys: | 
      image.public.key=771 
      rsa.public.key=42
  ```
### Get the ConfigMaps

  `kubectl -n <namespace-name> get cm`

  ```
  NAME             DATA      AGE
  test-cm          3         23s
  ```

### Describe the Configmap

  `kubectl -n <namespace-name> describe cm test-cm`
 
  ```
  Name:         test-cm
  Namespace:    labs-sidda
  Labels:       <none>
  Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","data":{"database":"mongodb","database_uri":"mongodb://localhost:27017","keys":"image.public.key=771 \nrsa.public.key=42\n"},"kind":...

  Data
  ====
  keys:
  ----
  image.public.key=771
  rsa.public.key=42

  database:
  ----
  mongodb
  database_uri:
  ----
  mongodb://localhost:27017
  Events:  <none>

  ```

### Access the ConfigMaps from pods

1. Create a pod with a filename `sample-pod.yml`,to pull Environmental variables from the Configmaps.

2. Environmental variables are mentioned with a envFrom member.This references the ConfigMap and the data key to use within that ConfigMap.

3. Use the following command to create a pod.

  `kubectl -n <namespace-name> apply -f sample-pod.yml`

  ```  yaml
    apiVersion: v1
    kind: Pod 
    metadata:
      name: sample-pod 
    spec:
      containers: 
        - envFrom:
          - configMapRef:
              name: test-cm
          name: test-container
          image: nginx 
          imagePullPolicy: Always
          ports:
          - containerPort: 80 
      imagePullSecrets:
      - name: shaoketest
      
  ```
4. After creating the Pod, you will be able to access these environment variables, by using the following command.

  `kubectl -n <namespace-name> exec -it sample-pod sh`
  
  ```
  # env
  KUBERNETES_PORT=tcp://10.96.0.1:443
  KUBERNETES_SERVICE_PORT=443
  database=mongodb
  HOSTNAME=sample-pod
  database_uri=mongodb://localhost:27017
  HOME=/root
  keys=image.public.key=771
  rsa.public.key=42

  TERM=xterm
  KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
  NGINX_VERSION=1.15.12-1~stretch
  PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
  KUBERNETES_PORT_443_TCP_PORT=443
  NJS_VERSION=1.15.12.0.3.1-1~stretch
  KUBERNETES_PORT_443_TCP_PROTO=tcp
  KUBERNETES_SERVICE_PORT_HTTPS=443
  KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
  KUBERNETES_SERVICE_HOST=10.96.0.1
  PWD=/
  ```

### Edit the ConfigMap

  `kubectl -n <namespace-name> edit cm test-cm`


### Delete the ConfigMap
 
  `kubectl -n <namespace-name> delete cm test-cm`
 
  ```
  configmap "test-cm" deleted
  ```

## Practice 5: Secrets

* Secrets are  objects in kubernetes, that contains sensitive information such as credentials, tokens. They are stored in `etcd`, these accessible by kubernetes API server and it can be mounted as files into a pod, that pod needs to access them. The same secret can be mounted into multiple pods.
* Another perspective of is to use secret as Environmental variables. Secrets in a pod always stored in a memory(tmfs-temporary file storage)
* Secrets are created using the Kubernetes API or the kubectl command-line tool. Secrets hold one or more data elements as a collection of key/value pairs.

### Create a secret

There are different ways to create secrets in kubernetes. Use any one of the following ways.

1. create local files using `kubectl` tool.
2. create by using a manifest file of `kind:secret`.
    
### Create the Secrets from Files using Kubectl

1. Create local files with sensitive information like passwords and ssh keys and then convert them into a Secret stored and managed by the Kubernetes API server. Kubernetes will create key-value pairs using the filenames and their contents and encode the sensitive data in `base64` format.

2. Create the files with the username and password on your local machine.

  `echo -n 'test' > ./username.txt`

  `echo -n 'jiki893kdjnsaasdsa' > ./password.txt`

  `kubectl create secret`  command to package files into a Secret and create a Secret API object on the API server.
  
  `kubectl -n <namespace-name> create secret generic db --from-file=/home/documents/username.txt --from-file=/home/documents/password.txt`
 
  ```
  secret "db" created
  ```

### Get the secrets

1. Verify it by using the following command to get the secrets created.

  `kubectl get secrets -n <namespace-name>`
   
  ```
    NAME                  TYPE                                  DATA      AGE
    db                    Opaque                                2         1m
  ```  

### Describe the secrets

1. Describe will shows you detailed information about the seceret, use `kubectl describe`.

  `kubectl describe secrets db -n <namespace-name>`

  ```
  Name:         db-auth
  Namespace:    default
  Labels:       <none>
  Annotations:  <none>
  Type:  Opaque
  Data
  ====
  password.txt:  15 bytes
  username.txt:  5 bytes
  ```
2. The `type:Opaque` refers to the Secret means that from Kubernetes point of view the contents of the Secret is unstructured.

### Edit the Secrets

* Edit the secrets by using a following command, will popup a file to edit any changes. 

  `kubectl edit secrets <secretname> -n <namespace-name>`


### Create a Secret for Azure Container Registry

1. Create a secret for Azure Container Registry (ACR) to push and pull the docker images.

  `kubectl create secret docker-registry <secret-name> --docker-server=<acr registry url> --docker-username=<username> --docker-password=<password> --docker-email=<email id> -n <namespace-name>`

2. List out the secrets by using following command.

  `kubectl get secrets -n <namespace-name>`

### Access the secrets from the pod (test-pod.yml)

1. Use the created secrets in the pod yaml and access the secrets.

  ```  yaml
  apiVersion: v1
  kind: Pod 
  metadata:
    name: sample-pod 
  spec:
    containers: 
      - envFrom:
        - configMapRef:
            name: test-cm
        name: test-container
        image: <docker-image-name>
        imagePullPolicy: Always
        ports:
        - containerPort: 80 
      secret:
              defaultMode: 420
              secretName: <db-secret-name>  
    imagePullSecrets:
    - name: <acr-secret-name>
  ```

## Practice 6: Deployments

A deployment is a supervisor for pods, it provides declarative updates for Pods and ReplicaSets.
A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time.

![alt-txt](https://raw.githubusercontent.com/sysgain/qloudable-tl-labs/aks/AKS%20Course/images/deployments.png?token=AIMANTACR2JFWY6VCUJX4PK5JJWB2)

### Create a Deployment

1. Create a deployment that creates a replicaset to bring up three nginx pods.

2. You can create the deployment in a particular namespace or it will deploy in the default namespace. Save the YAML file and create using `kubectl create -f <file path>`

3. Create a namespace using `kubectl create ns <namespace-name>`

  ```  yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment
    namespace: <namespace-name>
    labels:
      app: nginx
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginx
          image: nginx:1.7.9
          ports:
          - containerPort: 80
  ```

3. Get the deployment using `kubectl -n <namespace-name> get deployments`

  ```
  NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3         3         3            3           4m
  ```

4. A Deployment named nginx-deployment is created, indicated by the .metadata.name field.

5. The Deployment creates three replicated Pods, indicated by the replicas field.

6. The selector field defines how the Deployment finds which Pods to manage. In this case, you simply select a label that is defined in the Pod template (app: nginx). However, more sophisticated selection rules are possible, as long as the Pod template itself satisfies the rule.

7. Get the pods in nginx deployment using `kubectl -n <namespace-name> get pods`

  ```
  NAME                                READY     STATUS    RESTARTS   AGE
  nginx-deployment-5c689d88bb-5h7vx   1/1       Running   0          9m
  nginx-deployment-5c689d88bb-mbqzg   1/1       Running   0          9m
  nginx-deployment-5c689d88bb-txdj7   1/1       Running   0          9m
  ```

### Updating a Deployment

1. If you want to edit the existing deployment you can use `kubectl -n <namespace-name> edit deployment <deployment-name>`



### Delete the pod

delete the first pod using kubectl -n <namespacename> delete pod <podname>

once the pod got deleted new pod will comeup with the same configuration

`$ kubectl -n beginner delete pod nginx-deployment-76bf4969df-dl6z6`

```
pod "nginx-deployment-76bf4969df-dl6z6" deleted

```

Get the pods in nginx deployment using kubectl -n <namespace-name> get pods

See here new pod is created

```
NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-76bf4969df-dr8pr   1/1       Running   0          21s
nginx-deployment-76bf4969df-ftzwm   1/1       Running   0          2m
nginx-deployment-76bf4969df-gfkp6   1/1       Running   0          2m

```

### Troubleshooting the Kubernetes error, ImagePullBackOff


Get the pods in nginx deployment using kubectl -n <namespace-name> get pods
  

```
NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-697f5c8c94-jh7bd   0/1       ImagePullBackOff   0         49s
nginx-deployment-76bf4969df-dr8pr   1/1       Running            0          6m
nginx-deployment-76bf4969df-ftzwm   1/1       Running            0          8m
nginx-deployment-76bf4969df-gfkp6   1/1       Running            0          8m

```

When the pods get  imagepullbackoff error, following are can be the reasons.

First you desrcribe the pod using `kubectl -n (namespace-name) describe <pod podname>` 

Here figure out the error messgage.

*  Invalid container image:  This error says that either the image has a non-existent container registry name or  don't have access to it. 

* Invalid container image tag: Another variation to this is if the container tag does not exist.

* Unable to pull a private image: As we mentioned above for the invalid image name, a private image that you don’t have access to will return the same error messages.


### Troubleshooting the Kubernetes error, Crashloopbackoff

The pod is starting and crashing then starting again and crashing again that the pod get the “CrashLoopBackOff” error and no of restarts incresed.

```
NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-697f5c8c94-jh7bd   0/1       CrashLoopBackOff    0         49s
nginx-deployment-76bf4969df-dr8pr   1/1       Running             0          6m
nginx-deployment-76bf4969df-ftzwm   1/1       Running             0          8m

```

**describe the pod**

First you desrcribe the pod using `kubectl -n (namespace-name) describe <pod podname>`

This describes that  Back-off restarting failed container.This  means that Kubernetes started your container, then the container subsequently exited. As we all know, the Docker container should hold and keep pid 1 running or the container exits. When the container exits, Kubernetes will try to restart it. After restarting it a few times, it will declare this BackOff state. However, Kubernetes will keep on trying to restart it.

**logs of the pod**

Check the logs of the pod using `kubectl -n (namespace-name) logs <pod podname>`


### Conclusion:
 
Congratulations! You have successfully completed the Kubernetes beginners lab. In this lab, you created namespaces, Pods, Service, ConfigMaps, Secrets, Deployments.  

Feel free to continue exploring or start a new lab.

Thank you for taking this training lab!
